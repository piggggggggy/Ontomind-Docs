# 20250817

> data/schemas 구현 이후 다음 스텝

---

## 0) 목표 요약 (동작하는 최소 루프)

OML(TBox) → IR → generated(JSON Schema/요약) → instances 검증 → 프롬프트 조립 → LLM 호출 → JSON 응답 검증

⸻

## 1) 파서 & IR (packages/dsl, packages/core)

- 해야 할 일
    1. `tbox/*.yml` + `ontomind.oml.yml` 머지 → OML 파싱
    2. 파싱 결과를 IR 객체(클래스/관계/의도/정책/컨텍스트)로 변환
    3. 의미론 검증(초판): 참조 무결성(domain/range가 존재하는 클래스인지), 중복 id 방지
- 작업 포인트
    - `packages/core`: IR 타입 정의 (OMClass, OMRelationType, OMIntent 등)
    - `packages/dsl`: parseOML(yamlText | filePaths): IR
    - `tools/merge-oml.ts`: 지금 만든 병합 스크립트를 정식화

⸻

## 2) 코드젠 (packages/codegen → data/generated)

- 산출물
    - `tbox.schema.json`: 클래스/속성/관계 JSON Schema (앱 폼/검증 재사용)
    - `intents.schema.json`: 각 Intent 입·출력 JSON Schema
    - `prompt-summary.json`: LLM에 실을 압축 스키마 요약(클래스/관계/규칙 핵심만)
    - `types.d.ts`: 앱에서 타입 안전하게 쓰는 선언 파일
- 작업 포인트
    - Ajv 호환 JSON Schema로 내보내기
    - prompt-summary.json에는 토큰 절약용으로 핵심만: 클래스 라벨 + 속성 키/타입, 범용 관계 목록, 간단 규칙(카디널리티)

⸻

## 3) 검증기 (packages/validator)

- 해야 할 일
    - `abox.entity.schema.yml`, `abox.relation.schema.yml`로 형식 검증
    - 클래스/속성 존재 여부, enum 일치, 카디널리티/역관계 의미론 검증
- API
    - `validateEntity(entity, ir)` / `validateRelation(rel, ir)`
    - `validateInstances(dir)`: JSONL 스트림 검증(줄 단위 에러 리포트)

⸻

## 4) 프롬프트 어셈블러 (packages/prompt)

- 입력
    - IR, prompt-summary.json, 선택된 context, intent, targets[], instances/*
- 출력
    - { system, user, toolSchema, evidence }
- 로직
    - 컨텍스트 필터로 인스턴스 서브셋 선택
    - 관련 이웃(관계 그래프 hop=1) 조인
    - 정책 적용(금지/선호), 출처/신뢰도 포함

⸻

## 5) LLM 포트 (packages/llm)

- 공통 인터페이스
    - run({ system, user, toolSchema }): { json, raw, usage }
    - 우선 하나만 연결(예: OpenAI)
    - 모델/키는 env, 재시도/리밸리데이션(스키마 실패 시 재질의) 포함

⸻

## 6) Next.js 앱 2개 (apps/editor, apps/chat)

### apps/editor (TBox 편집기 v0)

- 화면
    - Classes / RelationTypes / Intents / Contexts / Policies 탭
    - 각 항목 CRUD + JSON Schema 미리보기
- 데이터 흐름
    - 편집 → ontomind.oml.yml 혹은 tbox/*.yml 업데이트
    - 저장 시: merge → parse → codegen → generated 갱신
- 초기만 파일 기반으로 시작 (서버 라우트에서 FS write)

### apps/chat (챗 UI v0)

- 화면
    - 왼쪽: Context/Intent 선택 + Target 검색
    - 중앙: 메시지 스트림(JSON 결과+근거 표시)
    - 오른쪽: 스키마 요약 뷰(prompt-summary)
- 흐름
    - 선택 → /api/assemble 호출 → LLM 포트 → 응답 JSON 검증 → 렌더

⸻

## 7) CLI (tools/cli → om)

- `om validate` : OML + instances 전체 검증
- `om codegen`  : IR→generated 전부 생성
- `om assemble --intent Diagnose --target <id>` : 프롬프트 미리보기

⸻

## 8) CI 파이프라인

1. schemas/ 변경 → meta.schema.yml 문법 검증
2. merge + parse → 의미론 검증
3. codegen → data/generated/* 갱신
4. instances/*.jsonl 검증
5. 앱 빌드 + 간단 E2E(assemble→LLM 목킹)

⸻

## 9) 바로 넣어둘 스크립트 제안 (루트 package.json)

```json
{
  "scripts": {
    "oml:merge": "tsx tools/merge-oml.ts",
    "oml:parse": "tsx tools/parse-oml.ts",
    "oml:codegen": "tsx tools/codegen.ts",
    "oml:validate": "tsx tools/validate-instances.ts",
    "dev:editor": "next dev apps/editor",
    "dev:chat": "next dev apps/chat"
  }
}
```

⸻

## 10) 첫 구현 순서(빠른 체감 루트)

1. merge + parse: IR 메모리 구조 완성 (classes/relationTypes/intents/contexts/policies)
2. codegen: prompt-summary.json만 먼저 뽑기 (가장 빨리 챗 효과를 줌)
3. apps/chat에서 prompt-summary.json + 소수 인스턴스로 LLM 호출
4. validator 붙여 응답 JSON 형식 강제
5. editor는 CRUD 없이 읽기 전용 뷰부터(스키마 요약/관계 그래프)

⸻
